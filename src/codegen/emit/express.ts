/**
 * Emit Express route registration code
 */

import path from 'node:path';
import type { Config } from '../../config/types.js';
import type { ControllerInfo, MethodInfo } from '../../ast/scanControllers.js';

export function emitExpressRoutes(config: Config, controllers: ControllerInfo[]): string {
  const controllerImports: string[] = [];
  const routeDefinitions: string[] = [];
  const dtoClasses: Set<string> = new Set();

  // Collect imports and build route definitions
  for (const controller of controllers) {
    // Import controller class
    const relativePath = getRelativePath(
      config.generation.outputs.routes,
      controller.filePath,
      config.generation.rootDir
    );
    controllerImports.push(`import { ${controller.className} } from '${relativePath}.js';`);

    // Build route definitions
    for (const method of controller.methods) {
      const fullPath = getFullPath(config.generation.basePath, controller.path, method.path);
      if (method.dtoName) {
        dtoClasses.add(method.dtoName);
        // We assume DTOs are exported from the same file as the controller or can be found
        // In a real scenario, we'd need more robust DTO discovery
        controllerImports.push(`import { ${method.dtoName} } from '${relativePath}.js';`);
      }
      
      routeDefinitions.push(`
    app.${method.httpMethod}('${fullPath}', async (req: express.Request, res: express.Response, next: express.NextFunction) => {
      try {
        const controller = container.resolve<${controller.className}>(${controller.className});
        
        // Build DTO from request
        let dto: any = ${buildDtoExtraction(method, config)};
        
        ${method.dtoName ? `
        // Validate DTO
        if (typeof ${method.dtoName} !== 'undefined') {
          const validationResult = validateZod(createZodSchema(${method.dtoName}), dto);
          if (!validationResult.success) {
            return res.status(400).json({ 
              message: 'Validation failed', 
              errors: validationResult.errors 
            });
          }
          dto = validationResult.data;
        }` : ''}
        
        const result = await controller.${method.methodName}(dto);
        ${method.statusCode ? `res.status(${method.statusCode});` : ''}
        res.json(result);
      } catch (error) {
        next(error);
      }
    });
`.trim());
    }
  }

  // Filter unique imports (some DTOs might be in the same file)
  const uniqueImports = Array.from(new Set(controllerImports));

  // Determine imports for adorn-api. In tests we use relative paths, in production we use the package name.
  const adornApiImport = 'adorn-api';
  const zodAdapterImport = 'adorn-api/adapters/validation/zod.js';
  const errorMapperImport = 'adorn-api/adapters/errors/defaultMapper.js';

  // Generate the complete file
  return `// AUTOGENERATED BY ADORN-API - DO NOT EDIT
import express from 'express';
import { container } from '${adornApiImport}';
import { validateZod, createZodSchema } from '${zodAdapterImport}';
import { createErrorMapper } from '${errorMapperImport}';
${uniqueImports.join('\n')}

export function RegisterRoutes(app: express.Express): void {
${routeDefinitions.join('\n')}

  // Register error mapper middleware
  app.use(createErrorMapper());
}`;
}

function getFullPath(basePath: string, controllerPath: string, methodPath: string): string {
  const parts = [basePath, controllerPath, methodPath].filter(p => p && p !== '/');
  const fullPath = parts.map(p => p.replace(/^\/|\/$/g, '')).join('/');
  
  // Convert OpenAPI-style path params {param} to Express-style :param
  const expressPath = fullPath.replace(/\{([^}]+)\}/g, ':$1');
  
  return '/' + expressPath;
}

function getRelativePath(from: string, to: string, rootDir: string): string {
  // Normalize all paths using Node's path utilities
  const fromNormalized = path.normalize(from);
  const toNormalized = path.normalize(to);
  const rootNormalized = path.normalize(rootDir);
  
  // Resolve 'from' path (output file) relative to rootDir
  const fromAbsolute = path.isAbsolute(fromNormalized) 
    ? fromNormalized 
    : path.resolve(rootNormalized, fromNormalized);
  
  // 'to' is already absolute (from scanControllers)
  const toAbsolute = toNormalized;
  
  // Get the directory of the 'from' file using path.dirname
  const fromDir = path.dirname(fromAbsolute);
  
  // Remove .ts extension from target file
  const toWithoutExt = toAbsolute.replace(/\.ts$/, '');
  
  // Calculate relative path from 'from' directory to 'to' file
  const relative = path.relative(fromDir, toWithoutExt);
  
  // Normalize to use forward slashes for ES module imports
  // This ensures consistency across platforms
  const normalizedRelative = relative.split(path.sep).join('/');
  
  // Ensure we're using .js extension for ES modules
  // Handle same-directory case - don't return bare module name
  if (normalizedRelative === '.') {
    const filename = path.basename(toWithoutExt);
    return './' + filename;
  }
  
  return normalizedRelative;
}

function buildDtoExtraction(method: MethodInfo, config: Config): string {
  // If no DTO, use undefined
  if (!method.dtoName) {
    return 'undefined';
  }

  const { defaultDtoFieldSource, collisionPolicy } = config.generation.inference;
  const parts: string[] = ['{'];
  const pathParams = method.pathParams || [];

  const sources: string[] = [];

  // 1. Handle Query/Body based on smart/configured source
  if (defaultDtoFieldSource === 'query') {
    sources.push('...req.query');
  } else if (defaultDtoFieldSource === 'body') {
    sources.push('...req.body');
  } else if (defaultDtoFieldSource === 'smart') {
    // Smart merge: Query first, then Body (body wins over query)
    sources.push('...req.query');
    if (['post', 'put', 'patch'].includes(method.httpMethod)) {
      sources.push('...req.body');
    }
  }

  // 2. Handle collision policy and path params
  if (collisionPolicy === 'query-wins') {
    // Path params first, then spread query/body (so they win)
    if (pathParams.length > 0) {
      for (const param of pathParams) {
        parts.push(`  ${param}: req.params.${param},`);
      }
    }
    for (const source of sources) {
      parts.push(`  ${source},`);
    }
  } else {
    // default: path-wins
    // Spread query/body first, then individual path params (so they win)
    for (const source of sources) {
      parts.push(`  ${source},`);
    }
    if (pathParams.length > 0) {
      for (const param of pathParams) {
        parts.push(`  ${param}: req.params.${param},`);
      }
    }
  }

  parts.push('}');

  return parts.join('\n        ');
}
