/**
 * Emit Express route registration code
 */

import path from 'node:path';
import type { Config } from '../../config/types.js';
import type { ControllerInfo, MethodInfo } from '../../ast/scanControllers.js';

export function emitExpressRoutes(config: Config, controllers: ControllerInfo[]): string {
  const controllerImports: string[] = [];
  const routeDefinitions: string[] = [];

  // Collect imports and build route definitions
  for (const controller of controllers) {
    // Import controller class
    const relativePath = getRelativePath(
      config.generation.outputs.routes,
      controller.filePath,
      config.generation.rootDir
    );
    controllerImports.push(`import { ${controller.className} } from '${relativePath}.js';`);

    // Build route definitions
    for (const method of controller.methods) {
      const fullPath = getFullPath(config.generation.basePath, controller.path, method.path);
      
      routeDefinitions.push(`
    app.${method.httpMethod}('${fullPath}', async (req, res, next) => {
      try {
        const controller = new ${controller.className}();
        
        // Build DTO from request
        const dto = ${buildDtoExtraction(method, config)};
        
        const result = await controller.${method.methodName}(dto);
        ${method.statusCode ? `res.status(${method.statusCode});` : ''}
        res.json(result);
      } catch (error) {
        next(error);
      }
    });
`.trim());
    }
  }

  // Generate the complete file
  return `// AUTOGENERATED BY ADORN-API - DO NOT EDIT
import express from 'express';
${controllerImports.join('\n')}

export function RegisterRoutes(app: express.Express): void {
${routeDefinitions.join('\n')}
}`;
}

function getFullPath(basePath: string, controllerPath: string, methodPath: string): string {
  const parts = [basePath, controllerPath, methodPath].filter(p => p && p !== '/');
  const fullPath = parts.map(p => p.replace(/^\/|\/$/g, '')).join('/');
  
  // Convert OpenAPI-style path params {param} to Express-style :param
  const expressPath = fullPath.replace(/\{([^}]+)\}/g, ':$1');
  
  return '/' + expressPath;
}

function getRelativePath(from: string, to: string, rootDir: string): string {
  // Normalize all paths using Node's path utilities
  const fromNormalized = path.normalize(from);
  const toNormalized = path.normalize(to);
  const rootNormalized = path.normalize(rootDir);
  
  // Resolve 'from' path (output file) relative to rootDir
  const fromAbsolute = path.isAbsolute(fromNormalized) 
    ? fromNormalized 
    : path.resolve(rootNormalized, fromNormalized);
  
  // 'to' is already absolute (from scanControllers)
  const toAbsolute = toNormalized;
  
  // Get the directory of the 'from' file using path.dirname
  const fromDir = path.dirname(fromAbsolute);
  
  // Remove .ts extension from target file
  const toWithoutExt = toAbsolute.replace(/\.ts$/, '');
  
  // Calculate relative path from 'from' directory to 'to' file
  const relative = path.relative(fromDir, toWithoutExt);
  
  // Normalize to use forward slashes for ES module imports
  // This ensures consistency across platforms
  const normalizedRelative = relative.split(path.sep).join('/');
  
  // Ensure we're using .js extension for ES modules
  // Handle same-directory case - don't return bare module name
  if (normalizedRelative === '.') {
    const filename = path.basename(toWithoutExt);
    return './' + filename;
  }
  
  return normalizedRelative;
}

function buildDtoExtraction(method: MethodInfo, config: Config): string {
  // If no DTO, use undefined
  if (!method.dtoName) {
    return 'undefined';
  }

  const { defaultDtoFieldSource } = config.generation.inference;
  const parts: string[] = ['{'];
  const pathParams = method.pathParams || [];

  // Extract body params first (for POST, PUT, PATCH requests)
  if (['post', 'put', 'patch'].includes(method.httpMethod) && defaultDtoFieldSource !== 'query') {
    // Filter out path params and undefined values from body to prevent them from overriding path params
    parts.push(`  ...Object.fromEntries(`);
    parts.push(`    Object.entries(req.body).filter(([key, value]) =>`);
    parts.push(`      !${JSON.stringify(pathParams)}.includes(key) && value !== undefined`);
    parts.push(`    )`);
    parts.push(`  ),`);
  }

  // Handle query params based on configuration (middle priority)
  if (defaultDtoFieldSource === 'query') {
    // All non-path params come from query
    parts.push(`  ...Object.fromEntries(`);
    parts.push(`    Object.entries(req.query).filter(([key]) => !${JSON.stringify(pathParams)}.includes(key))`);
    parts.push(`  ),`);
  } else if (defaultDtoFieldSource === 'smart') {
    // Smart mode: query params come from req.query
    parts.push(`  ...Object.fromEntries(`);
    parts.push(`    Object.entries(req.query).filter(([key]) => !${JSON.stringify(pathParams)}.includes(key))`);
    parts.push(`  ),`);
  }

  // Extract path params last (highest priority - cannot be overwritten)
  if (pathParams.length > 0) {
    for (const param of pathParams) {
      parts.push(`  ${param}: req.params.${param},`);
    }
  }

  parts.push('}');

  return parts.join('\n        ');
}
