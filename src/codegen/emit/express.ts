/**
 * Emit Express route registration code
 */

import path from 'node:path';
import type { Config } from '../../config/types.js';
import type { ControllerInfo, MethodInfo } from '../../ast/scanControllers.js';

export function emitExpressRoutes(config: Config, controllers: ControllerInfo[]): string {
  const controllerImports: string[] = [];
  const routeDefinitions: string[] = [];

  // Collect imports and build route definitions
  for (const controller of controllers) {
    // Import controller class
    const relativePath = getRelativePath(
      config.generation.outputs.routes,
      controller.filePath,
      config.generation.rootDir
    );
    controllerImports.push(`import { ${controller.className} } from '${relativePath}.js';`);

    // Build route definitions
    for (const method of controller.methods) {
      const fullPath = getFullPath(config.generation.basePath, controller.path, method.path);
      
      routeDefinitions.push(`
    app.${method.httpMethod}('${fullPath}', async (req, res, next) => {
      try {
        const controller = new ${controller.className}();
        
        // Build DTO from request
        const dto = ${buildDtoExtraction(method, config)};
        
        const result = await controller.${method.methodName}(dto);
        ${method.statusCode ? `res.status(${method.statusCode});` : ''}
        res.json(result);
      } catch (error) {
        next(error);
      }
    });
`.trim());
    }
  }

  // Generate the complete file
  return `// AUTOGENERATED BY ADORN-API - DO NOT EDIT
import express from 'express';
${controllerImports.join('\n')}

export function RegisterRoutes(app: express.Express): void {
${routeDefinitions.join('\n')}
}`;
}

function getFullPath(basePath: string, controllerPath: string, methodPath: string): string {
  const parts = [basePath, controllerPath, methodPath].filter(p => p && p !== '/');
  const fullPath = parts.map(p => p.replace(/^\/|\/$/g, '')).join('/');
  
  // Convert OpenAPI-style path params {param} to Express-style :param
  const expressPath = fullPath.replace(/\{([^}]+)\}/g, ':$1');
  
  return '/' + expressPath;
}

function getRelativePath(from: string, to: string, rootDir: string): string {
  // Normalize paths to use forward slashes
  const fromNormalized = from.replace(/\\/g, '/');
  const toNormalized = to.replace(/\\/g, '/');
  const rootNormalized = rootDir.replace(/\\/g, '/');
  
  // Resolve 'from' path (output file) relative to rootDir
  let fromAbsolute = path.isAbsolute(fromNormalized) 
    ? fromNormalized 
    : path.resolve(rootNormalized, fromNormalized);
  
  // 'to' is already absolute (from scanControllers)
  const toAbsolute = toNormalized;
  
  // Normalize resolved path to forward slashes for consistent handling
  fromAbsolute = fromAbsolute.replace(/\\/g, '/');
  
  // Get the directory of the 'from' file
  const fromDir = fromAbsolute.replace(/[^/]+$/, '');
  const toDir = toAbsolute.replace(/\.ts$/, '');
  
  // Calculate relative path from 'from' directory to 'to' file
  let relative = path.relative(fromDir, toDir);
  
  // Normalize to use forward slashes and remove .ts extension
  relative = relative.replace(/\\/g, '/').replace(/\.ts$/, '');
  
  // Ensure we're using .js extension for ES modules
  return relative || '.';
}

function buildDtoExtraction(method: MethodInfo, config: Config): string {
  // If no DTO, use undefined
  if (!method.dtoName) {
    return 'undefined';
  }

  const { defaultDtoFieldSource } = config.generation.inference;
  const parts: string[] = ['{'];
  const pathParams = method.pathParams || [];

  // Extract path params (highest priority)
  if (pathParams.length > 0) {
    for (const param of pathParams) {
      parts.push(`  ${param}: req.params.${param},`);
    }
  }

  // Handle query params based on configuration
  if (defaultDtoFieldSource === 'query') {
    // All non-path params come from query
    parts.push(`  ...Object.fromEntries(`);
    parts.push(`    Object.entries(req.query).filter(([key]) => !${JSON.stringify(pathParams)}.includes(key))`);
    parts.push(`  ),`);
  } else if (defaultDtoFieldSource === 'smart') {
    // Smart mode: query params come from req.query
    parts.push(`  ...Object.fromEntries(`);
    parts.push(`    Object.entries(req.query).filter(([key]) => !${JSON.stringify(pathParams)}.includes(key))`);
    parts.push(`  ),`);
  }

  // Extract body params (for POST, PUT, PATCH requests)
  if (['post', 'put', 'patch'].includes(method.httpMethod) && defaultDtoFieldSource !== 'query') {
    parts.push(`  ...req.body,`);
  }

  parts.push('}');

  return parts.join('\n        ');
}
