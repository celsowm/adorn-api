/**
 * Emit Express route registration code
 */

import path from 'node:path';
import type { Config } from '../../config/types.js';
import type { ControllerInfo } from '../../ast/scanControllers.js';

export function emitExpressRoutes(config: Config, controllers: ControllerInfo[]): string {
  const imports: string[] = [];
  const controllerImports: string[] = [];
  const routeDefinitions: string[] = [];

  // Collect imports and build route definitions
  for (const controller of controllers) {
    // Import controller class
    const relativePath = getRelativePath(
      config.generation.outputs.routes,
      controller.filePath,
      config.generation.rootDir
    );
    controllerImports.push(`import { ${controller.className} } from '${relativePath}.js';`);

    // Build route definitions
    for (const method of controller.methods) {
      const fullPath = getFullPath(config.generation.basePath, controller.path, method.path);
      const controllerInstanceVar = `_${controller.className.toLowerCase()}`;
      
      routeDefinitions.push(`
    app.${method.httpMethod}('${fullPath}', async (req, res, next) => {
      try {
        const controller = new ${controller.className}();
        
        // Build DTO from request
        const dto = ${buildDtoExtraction(method, controllerInstanceVar)};
        
        const result = await controller.${method.methodName}(dto);
        ${method.statusCode ? `res.status(${method.statusCode});` : ''}
        res.json(result);
      } catch (error) {
        next(error);
      }
    });
`.trim());
    }
  }

  // Generate the complete file
  return `// AUTOGENERATED BY ADORN-API - DO NOT EDIT
import express from 'express';
${controllerImports.join('\n')}

export function RegisterRoutes(app: express.Express): void {
${routeDefinitions.join('\n')}
}
`;
}

function getFullPath(basePath: string, controllerPath: string, methodPath: string): string {
  const parts = [basePath, controllerPath, methodPath].filter(p => p && p !== '/');
  const fullPath = parts.map(p => p.replace(/^\/|\/$/g, '')).join('/');
  return '/' + fullPath;
}

function getRelativePath(from: string, to: string, rootDir: string): string {
  // Normalize paths to use forward slashes
  const fromNormalized = from.replace(/\\/g, '/');
  const toNormalized = to.replace(/\\/g, '/');
  const rootNormalized = rootDir.replace(/\\/g, '/');
  
  // Resolve 'from' path (output file) relative to rootDir
  let fromAbsolute = path.isAbsolute(fromNormalized) 
    ? fromNormalized 
    : path.resolve(rootNormalized, fromNormalized);
  
  // 'to' is already absolute (from scanControllers)
  const toAbsolute = toNormalized;
  
  // Normalize resolved path to forward slashes for consistent handling
  fromAbsolute = fromAbsolute.replace(/\\/g, '/');
  
  // Get the directory of the 'from' file
  const fromDir = fromAbsolute.replace(/[^/]+$/, '');
  const toDir = toAbsolute.replace(/\.ts$/, '');
  
  // Calculate relative path from 'from' directory to 'to' file
  let relative = path.relative(fromDir, toDir);
  
  // Normalize to use forward slashes and remove .ts extension
  relative = relative.replace(/\\/g, '/').replace(/\.ts$/, '');
  
  // Ensure we're using .js extension for ES modules
  return relative || '.';
}

function buildDtoExtraction(method: any, instanceVar: string): string {
  // If no DTO, use undefined
  if (!method.dtoName) {
    return 'undefined';
  }

  // Build DTO object extraction
  const parts: string[] = ['{'];
  
  // For simplicity, extract from req.body for now
  // In a full implementation, this would also handle path params, query params, etc.
  parts.push(`  ...req.body,`);
  
  // Add path params if any
  if (method.pathParams && method.pathParams.length > 0) {
    for (const param of method.pathParams) {
      parts.push(`  ${param}: req.params.${param},`);
    }
  }
  
  parts.push('}');
  
  return parts.join('\n        ');
}
