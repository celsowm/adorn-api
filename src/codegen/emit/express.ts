/**
 * Emit Express route registration code
 */

import type { Config } from '../../config/types.js';
import type { ControllerInfo } from '../../ast/scanControllers.js';

export function emitExpressRoutes(config: Config, controllers: ControllerInfo[]): string {
  const imports: string[] = [];
  const controllerImports: string[] = [];
  const routeDefinitions: string[] = [];

  // Collect imports and build route definitions
  for (const controller of controllers) {
    // Import controller class
    const relativePath = getRelativePath(config.generation.outputs.routes, controller.filePath);
    controllerImports.push(`import { ${controller.className} } from '${relativePath}.js';`);

    // Build route definitions
    for (const method of controller.methods) {
      const fullPath = getFullPath(config.generation.basePath, controller.path, method.path);
      const controllerInstanceVar = `_${controller.className.toLowerCase()}`;
      
      routeDefinitions.push(`
    app.${method.httpMethod}('${fullPath}', async (req, res, next) => {
      try {
        const controller = new ${controller.className}();
        
        // Build DTO from request
        const dto = ${buildDtoExtraction(method, controllerInstanceVar)};
        
        const result = await controller.${method.methodName}(dto);
        ${method.statusCode ? `res.status(${method.statusCode});` : ''}
        res.json(result);
      } catch (error) {
        next(error);
      }
    });
`.trim());
    }
  }

  // Generate the complete file
  return `// AUTOGENERATED BY ADORN-API - DO NOT EDIT
import express from 'express';
${controllerImports.join('\n')}

export function RegisterRoutes(app: express.Express): void {
${routeDefinitions.join('\n')}
}
`;
}

function getFullPath(basePath: string, controllerPath: string, methodPath: string): string {
  const parts = [basePath, controllerPath, methodPath].filter(p => p && p !== '/');
  const fullPath = parts.map(p => p.replace(/^\/|\/$/g, '')).join('/');
  return '/' + fullPath;
}

function getRelativePath(from: string, to: string): string {
  // Normalize paths to use forward slashes
  const fromNormalized = from.replace(/\\/g, '/');
  const toNormalized = to.replace(/\\/g, '/');
  
  const fromDir = fromNormalized.replace(/[^/]+$/, '');
  const toDir = toNormalized.replace(/\.ts$/, '');
  
  // Simple relative path calculation
  const fromParts = fromDir.split('/').filter(p => p && p !== '.');
  const toParts = toDir.split('/').filter(p => p && p !== '.');
  
  let commonParts = 0;
  while (commonParts < fromParts.length && commonParts < toParts.length && fromParts[commonParts] === toParts[commonParts]) {
    commonParts++;
  }
  
  const upParts = fromParts.length - commonParts - 1; // -1 for the file name
  const relativeParts = ['../'.repeat(Math.max(0, upParts)), ...toParts.slice(commonParts)];
  const relativePath = relativeParts.join('').replace(/\.ts$/, '');
  
  return relativePath || '.';
}

function buildDtoExtraction(method: any, instanceVar: string): string {
  // If no DTO, use undefined
  if (!method.dtoName) {
    return 'undefined';
  }

  // Build DTO object extraction
  const parts: string[] = ['{'];
  
  // For simplicity, extract from req.body for now
  // In a full implementation, this would also handle path params, query params, etc.
  parts.push(`  ...req.body,`);
  
  // Add path params if any
  if (method.pathParams && method.pathParams.length > 0) {
    for (const param of method.pathParams) {
      parts.push(`  ${param}: req.params.${param},`);
    }
  }
  
  parts.push('}');
  
  return parts.join('\n        ');
}
