import { metadataStorage } from "../metadata/metadata-storage.js";
import type { RouteMetadata } from "../types/metadata.js";

type UpdateOptions = {
  entity?: any;
  schema?: any;
};

const pendingUpdateRoutes = new Map<Function, RouteMetadata>();

export function attachPendingUpdateRoutesToController(
  controllerClass: Function,
): void {
  pendingUpdateRoutes.forEach((route, method) => {
    pendingUpdateRoutes.delete(method);

    const pendingMiddlewares = metadataStorage.getPendingMiddlewares(method);
    route.middlewares.push(...pendingMiddlewares);
    metadataStorage.clearPendingMiddlewares(method);

    const pendingGuards = metadataStorage.getPendingGuards(method);
    route.guards.push(...pendingGuards);
    metadataStorage.clearPendingGuards(method);

    const pendingParams = metadataStorage.getPendingParameters(method);
    if (pendingParams.length > 0) {
      route.parameters = pendingParams.map((p, index) => ({
        name: p.name,
        type: p.type,
        index,
        schema: p.schema,
        required: p.type === "params" || p.type === "body",
      }));
    }
    metadataStorage.clearPendingParameters(method);

    metadataStorage.addRoute(controllerClass, route);
  });
}

function parseUpdateOptions(
  pathOrOptions?: string | UpdateOptions,
  options?: UpdateOptions,
): { path: string; options: UpdateOptions | undefined } {
  let path = "";
  let opts: UpdateOptions | undefined;

  if (typeof pathOrOptions === "string") {
    path = pathOrOptions;
    opts = options;
  } else if (typeof pathOrOptions === "object") {
    opts = pathOrOptions;
  }

  return { path, options: opts };
}

export function Update(
  pathOrOptions?: string | UpdateOptions,
  options?: UpdateOptions,
) {
  return function (
    _originalMethod: Function,
    _context: ClassMethodDecoratorContext,
  ): void {
    if (_context.kind !== "method") return;

    const methodName = String(_context.name);
    const parsed = parseUpdateOptions(pathOrOptions, options);

    let schema: any;

    // Store schema only if explicitly provided
    // Entity-based schemas will be generated by OpenApiGenerator after bootstrapEntities
    if (parsed.options?.schema) {
      schema = parsed.options.schema;
    }

    const route: RouteMetadata = {
      path: parsed.path,
      method: "PUT",
      handlerName: methodName,
      middlewares: [],
      guards: [],
      parameters: [],
      entity: parsed.options?.entity,
      schema,
    };

    pendingUpdateRoutes.set(_originalMethod, route);
  };
}
