import { metadataStorage } from "../metadata/metadata-storage.js";
import { SchemaModifier } from "../metal-orm-integration/schema-modifier.js";
import type { RouteMetadata } from "../types/metadata.js";

type ListOptions = {
  entity?: any;
  schema?: any;
  includeRelations?: string[];
  relationsDepth?: number;
};

const pendingListRoutes = new Map<Function, RouteMetadata>();

export function attachPendingListRoutesToController(
  controllerClass: Function,
): void {
  pendingListRoutes.forEach((route, method) => {
    pendingListRoutes.delete(method);

    const pendingMiddlewares = metadataStorage.getPendingMiddlewares(method);
    route.middlewares.push(...pendingMiddlewares);
    metadataStorage.clearPendingMiddlewares(method);

    const pendingGuards = metadataStorage.getPendingGuards(method);
    route.guards.push(...pendingGuards);
    metadataStorage.clearPendingGuards(method);

    const pendingParams = metadataStorage.getPendingParameters(method);
    if (pendingParams.length > 0) {
      route.parameters = pendingParams.map((p, index) => ({
        name: p.name,
        type: p.type,
        index,
        schema: p.schema,
        required: p.type === "params" || p.type === "body",
      }));
    }
    metadataStorage.clearPendingParameters(method);

    metadataStorage.addRoute(controllerClass, route);
  });
}

function parseListOptions(
  pathOrOptions?: string | ListOptions,
  options?: ListOptions,
): { path: string; options: ListOptions | undefined } {
  let path = "";
  let opts: ListOptions | undefined;

  if (typeof pathOrOptions === "string") {
    path = pathOrOptions;
    opts = options;
  } else if (typeof pathOrOptions === "object") {
    opts = pathOrOptions;
  }

  return { path, options: opts };
}

export function List(
  pathOrOptions?: string | ListOptions,
  options?: ListOptions,
) {
  return function (
    _originalMethod: Function,
    _context: ClassMethodDecoratorContext,
  ): void {
    if (_context.kind !== "method") return;

    const methodName = String(_context.name);
    const parsed = parseListOptions(pathOrOptions, options);

    let schema: any;

    // Only generate schema from SchemaModifier at decoration time
    // Entity-based schemas will be generated by OpenApiGenerator after bootstrapEntities
    if (parsed.options?.schema) {
      if (parsed.options.schema instanceof SchemaModifier) {
        schema = parsed.options.schema.toOpenApi();
      } else {
        schema = parsed.options.schema;
      }
    }

    const route: RouteMetadata = {
      path: parsed.path,
      method: "GET",
      handlerName: methodName,
      middlewares: [],
      guards: [],
      parameters: [],
      entity: parsed.options?.entity,
      schema,
      isArray: true,
      includeRelations: parsed.options?.includeRelations,
      relationsDepth: parsed.options?.relationsDepth,
    };

    pendingListRoutes.set(_originalMethod, route);
  };
}

export function createListHelper(entity: any) {
  return {
    omit: (...fields: string[]) => new SchemaModifier(entity).omit(...fields),
    only: (...fields: string[]) => new SchemaModifier(entity).only(...fields),
    include: (...relations: string[]) => {
      const modifier = new SchemaModifier(entity);
      const schema = modifier.toOpenApi();
      if (!schema.properties) return schema;
      schema.properties = {
        ...schema.properties,
        ...Object.fromEntries(
          relations.map((rel) => [
            rel,
            {
              type: "array",
              items: {
                $ref: `#/components/schemas/${rel.charAt(0).toUpperCase() + rel.slice(1)}`,
              },
            },
          ]),
        ),
      };
      return schema;
    },
    addComputed: (name: string, valueSchema: any) =>
      new SchemaModifier(entity).addComputed(name, valueSchema),
    rename: (mapping: Record<string, string>) =>
      new SchemaModifier(entity).rename(mapping),
  };
}
