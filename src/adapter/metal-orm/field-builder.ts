import {
  columnTypeToOpenApiFormat,
  columnTypeToOpenApiType,
  getColumnMap,
  getDecoratorMetadata,
  type ColumnDef,
  type TransformerMetadata
} from "metal-orm";
import type { SchemaNode, StringSchema } from "../../core/schema";
import { t } from "../../core/schema";
import type { FieldMeta } from "../../core/metadata";
import type { FieldOverride } from "../../core/decorators";

export type MetalDtoMode = "response" | "create" | "update";

export interface MetalDtoOptions {
  mode?: MetalDtoMode;
  include?: string[];
  exclude?: string[];
  overrides?: Record<string, FieldOverride>;
  description?: string;
  name?: string;
  additionalProperties?: boolean;
  /** Whether to throw errors instead of warnings for invalid metadata */
  strict?: boolean;
}

export function buildFields(
  target: any,
  options: MetalDtoOptions
): Record<string, FieldMeta> {
  const columns = getColumnMap(target);
  
  if (Object.keys(columns).length === 0) {
    const targetName = typeof target === "function" ? target.name : String(target);
    const message = 
      `Entity "${targetName}" has no columns. ` +
      `Make sure the entity class is decorated with @Entity and @Column decorators from metal-orm, ` +
      `and that it is imported/executed before calling createMetalCrudDtoClasses.`;
    
    if (options.strict) {
      throw new Error(`[adorn-api] ${message}`);
    }
    
    console.warn(`[adorn-api] Warning: ${message}`);
  }
  
  const include = options.include ? new Set(options.include) : undefined;
  const exclude = options.exclude ? new Set(options.exclude) : undefined;
  const mode = options.mode ?? "response";
  const transformerMetadata = getTransformerMetadata(target);
  const fields: Record<string, FieldMeta> = {};

  for (const [name, col] of Object.entries(columns)) {
    if (include && !include.has(name)) {
      continue;
    }
    if (exclude && exclude.has(name)) {
      continue;
    }
    if ((mode === "create" || mode === "update") && isAutoGenerated(col)) {
      continue;
    }

    fields[name] = buildFieldMeta(col, mode, transformerMetadata?.[name]);
  }

  if (options.overrides) {
    applyOverrides(fields, options.overrides, columns);
  }

  return fields;
}

export function buildFieldMeta(
  col: any,
  mode: MetalDtoMode,
  transformer?: TransformerMetadata
): FieldMeta {
  let schema = columnToSchemaNode(col);
  if (!col.notNull) {
    schema = t.nullable(schema);
  }
  schema = applyTransformerMetadata(schema, transformer, mode);

  const optional = isOptional(col, mode);
  const field: FieldMeta = { schema };
  if (optional) {
    field.optional = true;
  }
  if (col.comment) {
    field.description = col.comment;
  }
  return field;
}

function isOptional(col: ColumnDef, mode: MetalDtoMode): boolean {
  if (mode === "update") {
    return true;
  }
  if (mode === "create") {
    if (isAutoGenerated(col)) {
      return true;
    }
    if (!col.notNull) {
      return true;
    }
    if (col.default !== undefined) {
      return true;
    }
    return false;
  }
  return !(col.notNull || col.primary);
}

function isAutoGenerated(col: ColumnDef): boolean {
  return col.autoIncrement === true ||
    col.generated === "always" ||
    col.generated === "byDefault";
}

function columnToSchemaNode(col: ColumnDef): SchemaNode {
  const enumValues = getEnumValues(col);
  if (enumValues) {
    return t.enum(enumValues);
  }

  const openApiType = columnTypeToOpenApiType(col);
  switch (openApiType) {
    case "integer":
      return t.integer();
    case "number":
      return t.number();
    case "boolean":
      return t.boolean();
    case "string":
      return buildStringSchema(col);
    case "array":
      return t.array(t.any());
    case "object":
      return t.object({}, { additionalProperties: true });
    case "null":
      return t.null();
    default:
      return t.any();
  }
}

function buildStringSchema(col: ColumnDef): SchemaNode {
  const format = columnTypeToOpenApiFormat(col);
  const type = col.type.toUpperCase();
  const length = col.args?.[0];
  if ((type === "VARCHAR" || type === "CHAR") && typeof length === "number") {
    return t.string({
      format,
      maxLength: length,
      minLength: type === "CHAR" ? length : undefined
    });
  }
  return t.string({ format });
}

function getEnumValues(col: ColumnDef): string[] | undefined {
  if (col.type.toUpperCase() !== "ENUM") {
    return undefined;
  }
  if (!Array.isArray(col.args) || !col.args.every((value) => typeof value === "string")) {
    return undefined;
  }
  return col.args as string[];
}

function applyOverrides(
  fields: Record<string, FieldMeta>,
  overrides: Record<string, FieldOverride> | undefined,
  columns: Record<string, ColumnDef>
): Record<string, FieldMeta> {
  if (!overrides) {
    return fields;
  }
  const output: Record<string, FieldMeta> = { ...fields };
  const availableColumns = new Set(Object.keys(columns));
  for (const [name, override] of Object.entries(overrides)) {
    const field = output[name];
    if (!field) {
      if (availableColumns.has(name)) {
        continue;
      }
      throw new Error(`DTO field "${name}" does not exist.`);
    }
    output[name] = normalizeOverride(field, override);
  }
  return output;
}

function normalizeOverride(field: FieldMeta, override: FieldOverride): FieldMeta {
  if (isSchemaNode(override)) {
    return {
      schema: override,
      optional: (override as any).optional ?? field.optional ?? (field.schema as any).optional,
      description: field.description
    };
  }
  const schema = override.schema ?? field.schema;
  const optional = override.optional ?? (schema as any).optional ?? field.optional ?? (field.schema as any).optional;
  return {
    schema,
    optional,
    description: override.description ?? field.description
  };
}

function isSchemaNode(value: unknown): value is SchemaNode {
  return !!value && typeof value === "object" && "kind" in (value as SchemaNode);
}

function getTransformerMetadata(
  target: any
): Record<string, TransformerMetadata> | undefined {
  if (typeof target !== "function") {
    return undefined;
  }
  const meta = getDecoratorMetadata(target);
  if (!meta?.transformers?.length) {
    return undefined;
  }
  const output: Record<string, TransformerMetadata> = {};
  for (const entry of meta.transformers) {
    output[entry.propertyName] = entry.metadata;
  }
  return output;
}

function applyTransformerMetadata(
  schema: SchemaNode,
  transformer: TransformerMetadata | undefined,
  mode: MetalDtoMode
): SchemaNode {
  if (!transformer || !shouldApplyTransformers(transformer, mode)) {
    return schema;
  }
  if (schema.kind !== "string") {
    return schema;
  }
  const stringSchema = schema as StringSchema;
  for (const validator of transformer.validators ?? []) {
    applyStringValidator(stringSchema, validator);
  }
  return stringSchema;
}

function shouldApplyTransformers(
  transformer: TransformerMetadata,
  mode: MetalDtoMode
): boolean {
  if (transformer.executionOrder === "both") {
    return true;
  }
  if (mode === "response") {
    return transformer.executionOrder === "after-load";
  }
  return transformer.executionOrder === "before-save";
}

function applyStringValidator(
  schema: StringSchema,
  validator: { name?: string }
): void {
  const name = validator.name?.toLowerCase();
  switch (name) {
    case "email":
      if (!schema.format || schema.format === "email") {
        schema.format = "email";
      }
      break;
    case "length":
      applyLengthValidator(schema, validator);
      break;
    case "pattern":
      applyPatternValidator(schema, validator);
      break;
    case "alphanumeric":
      applyAlphanumericValidator(schema, validator);
      break;
    default:
      break;
  }
}

function applyLengthValidator(
  schema: StringSchema,
  validator: { [key: string]: unknown }
): void {
  const options = (validator as { options?: { min?: number; max?: number; exact?: number } }).options;
  if (!options) {
    return;
  }
  if (typeof options.exact === "number") {
    schema.minLength = options.exact;
    schema.maxLength = options.exact;
    return;
  }
  if (typeof options.min === "number") {
    schema.minLength = schema.minLength !== undefined
      ? Math.max(schema.minLength, options.min)
      : options.min;
  }
  if (typeof options.max === "number") {
    schema.maxLength = schema.maxLength !== undefined
      ? Math.min(schema.maxLength, options.max)
      : options.max;
  }
}

function applyPatternValidator(
  schema: StringSchema,
  validator: { [key: string]: unknown }
): void {
  if (schema.pattern) {
    return;
  }
  const options = (validator as { options?: { pattern?: RegExp } }).options;
  if (!options?.pattern) {
    return;
  }
  schema.pattern = options.pattern.source;
}

function applyAlphanumericValidator(
  schema: StringSchema,
  validator: { [key: string]: unknown }
): void {
  if (schema.pattern) {
    return;
  }
  const options = (validator as {
    options?: { allowSpaces?: boolean; allowUnderscores?: boolean; allowHyphens?: boolean }
  }).options;
  const extras: string[] = [];
  if (options?.allowSpaces) {
    extras.push(" ");
  }
  if (options?.allowUnderscores) {
    extras.push("_");
  }
  if (options?.allowHyphens) {
    extras.push("-");
  }
  schema.pattern = `^[a-zA-Z0-9${extras.join("")}]*$`;
}

/**
 * Validates that an entity has properly loaded metadata (columns).
 * Throws an error with helpful message if validation fails.
 * @param target - Entity class to validate
 * @param entityName - Optional entity name for better error messages
 * @throws Error if entity has no columns or invalid metadata
 */
export function validateEntityMetadata(
  target: any,
  entityName?: string
): void {
  const columns = getColumnMap(target);
  const name = entityName ?? (typeof target === "function" ? target.name : String(target));
  
  if (Object.keys(columns).length === 0) {
    throw new Error(
      `[adorn-api] Validation failed: Entity "${name}" has no columns. ` +
      `Make sure the entity class is decorated with @Entity and @Column decorators from metal-orm, ` +
      `and that it is imported/executed before calling createMetalCrudDtoClasses.`
    );
  }
}

/**
 * Validates entity metadata and returns whether it's valid.
 * Returns true if entity has columns, false otherwise.
 * @param target - Entity class to validate
 */
export function hasValidEntityMetadata(target: any): boolean {
  const columns = getColumnMap(target);
  return Object.keys(columns).length > 0;
}

/**
 * Merges the strict option from the extra parameters into the base options.
 * @param base - Base options object
 * @param extra - Extra options to merge (should contain strict property)
 * @returns Merged options
 */
export function mergeStrictOption(
  base: any | undefined,
  extra: any
): any {
  if (typeof extra === 'object' && 'strict' in extra) {
    return { ...base, strict: extra.strict };
  }
  return { ...base, ...extra };
}
