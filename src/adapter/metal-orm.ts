import type { ColumnDef } from "metal-orm";
import {
  columnTypeToOpenApiFormat,
  columnTypeToOpenApiType,
  getColumnMap
} from "metal-orm";
import type { DtoOptions, FieldOverride } from "../core/decorators";
import type { SchemaNode } from "../core/schema";
import { t } from "../core/schema";
import type { DtoConstructor } from "../core/types";
import { registerDto, type FieldMeta } from "../core/metadata";

export type MetalDtoMode = "response" | "create" | "update";

export interface MetalDtoOptions extends DtoOptions {
  mode?: MetalDtoMode;
  include?: string[];
  exclude?: string[];
  overrides?: Record<string, FieldOverride>;
}

export type MetalDtoTarget = Parameters<typeof getColumnMap>[0];

export function MetalDto(target: MetalDtoTarget, options: MetalDtoOptions = {}) {
  return (value: Function): void => {
    const fields = buildFields(target, options);
    registerDto(value as DtoConstructor, {
      name: options.name ?? value.name,
      description: options.description,
      fields,
      additionalProperties: options.additionalProperties
    });
  };
}

function buildFields(
  target: MetalDtoTarget,
  options: MetalDtoOptions
): Record<string, FieldMeta> {
  const columns = getColumnMap(target);
  const include = options.include ? new Set(options.include) : undefined;
  const exclude = options.exclude ? new Set(options.exclude) : undefined;
  const mode = options.mode ?? "response";
  const fields: Record<string, FieldMeta> = {};

  for (const [name, col] of Object.entries(columns)) {
    if (include && !include.has(name)) {
      continue;
    }
    if (exclude && exclude.has(name)) {
      continue;
    }
    if ((mode === "create" || mode === "update") && isAutoGenerated(col)) {
      continue;
    }
    fields[name] = buildFieldMeta(col, mode);
  }

  return applyOverrides(fields, options.overrides);
}

function buildFieldMeta(col: ColumnDef, mode: MetalDtoMode): FieldMeta {
  let schema = columnToSchemaNode(col);
  if (!col.notNull) {
    schema = t.nullable(schema);
  }

  const optional = isOptional(col, mode);
  const field: FieldMeta = { schema };
  if (optional) {
    field.optional = true;
  }
  if (col.comment) {
    field.description = col.comment;
  }
  return field;
}

function isOptional(col: ColumnDef, mode: MetalDtoMode): boolean {
  if (mode === "update") {
    return true;
  }
  if (mode === "create") {
    if (isAutoGenerated(col)) {
      return true;
    }
    if (!col.notNull) {
      return true;
    }
    if (col.default !== undefined) {
      return true;
    }
    return false;
  }
  return !(col.notNull || col.primary);
}

function isAutoGenerated(col: ColumnDef): boolean {
  return col.autoIncrement === true ||
    col.generated === "always" ||
    col.generated === "byDefault";
}

function columnToSchemaNode(col: ColumnDef): SchemaNode {
  const enumValues = getEnumValues(col);
  if (enumValues) {
    return t.enum(enumValues);
  }

  const openApiType = columnTypeToOpenApiType(col);
  switch (openApiType) {
    case "integer":
      return t.integer();
    case "number":
      return t.number();
    case "boolean":
      return t.boolean();
    case "string":
      return buildStringSchema(col);
    case "array":
      return t.array(t.any());
    case "object":
      return t.object({}, { additionalProperties: true });
    case "null":
      return t.null();
    default:
      return t.any();
  }
}

function buildStringSchema(col: ColumnDef): SchemaNode {
  const format = columnTypeToOpenApiFormat(col);
  const type = col.type.toUpperCase();
  const length = col.args?.[0];
  if ((type === "VARCHAR" || type === "CHAR") && typeof length === "number") {
    return t.string({
      format,
      maxLength: length,
      minLength: type === "CHAR" ? length : undefined
    });
  }
  return t.string({ format });
}

function getEnumValues(col: ColumnDef): string[] | undefined {
  if (col.type.toUpperCase() !== "ENUM") {
    return undefined;
  }
  if (!Array.isArray(col.args) || !col.args.every((value) => typeof value === "string")) {
    return undefined;
  }
  return col.args as string[];
}

function applyOverrides(
  fields: Record<string, FieldMeta>,
  overrides?: Record<string, FieldOverride>
): Record<string, FieldMeta> {
  if (!overrides) {
    return fields;
  }
  const output: Record<string, FieldMeta> = { ...fields };
  for (const [name, override] of Object.entries(overrides)) {
    const field = output[name];
    if (!field) {
      throw new Error(`DTO field "${name}" does not exist.`);
    }
    output[name] = normalizeOverride(field, override);
  }
  return output;
}

function normalizeOverride(field: FieldMeta, override: FieldOverride): FieldMeta {
  if (isSchemaNode(override)) {
    return {
      schema: override,
      optional: override.optional ?? field.optional ?? field.schema.optional,
      description: field.description
    };
  }
  const schema = override.schema ?? field.schema;
  const optional = override.optional ?? schema.optional ?? field.optional ?? field.schema.optional;
  return {
    schema,
    optional,
    description: override.description ?? field.description
  };
}

function isSchemaNode(value: unknown): value is SchemaNode {
  return !!value && typeof value === "object" && "kind" in (value as SchemaNode);
}
