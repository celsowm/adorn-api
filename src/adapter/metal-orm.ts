import type { ColumnDef, OrmSession } from "metal-orm";
import {
  columnTypeToOpenApiFormat,
  columnTypeToOpenApiType,
  getColumnMap
} from "metal-orm";
import type { DtoOptions, FieldOverride } from "../core/decorators";
import type { SchemaNode } from "../core/schema";
import { t } from "../core/schema";
import type { DtoConstructor } from "../core/types";
import { registerDto, type FieldMeta } from "../core/metadata";
import { HttpError } from "../core/errors";
import { coerce } from "../core/coerce";
import { Dto, Field, MergeDto } from "../core/decorators";

export type MetalDtoMode = "response" | "create" | "update";

export interface MetalDtoOptions extends DtoOptions {
  mode?: MetalDtoMode;
  include?: string[];
  exclude?: string[];
  overrides?: Record<string, FieldOverride>;
}

export type MetalDtoTarget = Parameters<typeof getColumnMap>[0];

export function MetalDto(target: MetalDtoTarget, options: MetalDtoOptions = {}) {
  return (value: Function): void => {
    const fields = buildFields(target, options);
    registerDto(value as DtoConstructor, {
      name: options.name ?? value.name,
      description: options.description,
      fields,
      additionalProperties: options.additionalProperties
    });
  };
}

function buildFields(
  target: MetalDtoTarget,
  options: MetalDtoOptions
): Record<string, FieldMeta> {
  const columns = getColumnMap(target);
  const include = options.include ? new Set(options.include) : undefined;
  const exclude = options.exclude ? new Set(options.exclude) : undefined;
  const mode = options.mode ?? "response";
  const fields: Record<string, FieldMeta> = {};

  for (const [name, col] of Object.entries(columns)) {
    if (include && !include.has(name)) {
      continue;
    }
    if (exclude && exclude.has(name)) {
      continue;
    }
    if ((mode === "create" || mode === "update") && isAutoGenerated(col)) {
      continue;
    }
    fields[name] = buildFieldMeta(col, mode);
  }

  return applyOverrides(fields, options.overrides);
}

function buildFieldMeta(col: ColumnDef, mode: MetalDtoMode): FieldMeta {
  let schema = columnToSchemaNode(col);
  if (!col.notNull) {
    schema = t.nullable(schema);
  }

  const optional = isOptional(col, mode);
  const field: FieldMeta = { schema };
  if (optional) {
    field.optional = true;
  }
  if (col.comment) {
    field.description = col.comment;
  }
  return field;
}

function isOptional(col: ColumnDef, mode: MetalDtoMode): boolean {
  if (mode === "update") {
    return true;
  }
  if (mode === "create") {
    if (isAutoGenerated(col)) {
      return true;
    }
    if (!col.notNull) {
      return true;
    }
    if (col.default !== undefined) {
      return true;
    }
    return false;
  }
  return !(col.notNull || col.primary);
}

function isAutoGenerated(col: ColumnDef): boolean {
  return col.autoIncrement === true ||
    col.generated === "always" ||
    col.generated === "byDefault";
}

function columnToSchemaNode(col: ColumnDef): SchemaNode {
  const enumValues = getEnumValues(col);
  if (enumValues) {
    return t.enum(enumValues);
  }

  const openApiType = columnTypeToOpenApiType(col);
  switch (openApiType) {
    case "integer":
      return t.integer();
    case "number":
      return t.number();
    case "boolean":
      return t.boolean();
    case "string":
      return buildStringSchema(col);
    case "array":
      return t.array(t.any());
    case "object":
      return t.object({}, { additionalProperties: true });
    case "null":
      return t.null();
    default:
      return t.any();
  }
}

function buildStringSchema(col: ColumnDef): SchemaNode {
  const format = columnTypeToOpenApiFormat(col);
  const type = col.type.toUpperCase();
  const length = col.args?.[0];
  if ((type === "VARCHAR" || type === "CHAR") && typeof length === "number") {
    return t.string({
      format,
      maxLength: length,
      minLength: type === "CHAR" ? length : undefined
    });
  }
  return t.string({ format });
}

function getEnumValues(col: ColumnDef): string[] | undefined {
  if (col.type.toUpperCase() !== "ENUM") {
    return undefined;
  }
  if (!Array.isArray(col.args) || !col.args.every((value) => typeof value === "string")) {
    return undefined;
  }
  return col.args as string[];
}

function applyOverrides(
  fields: Record<string, FieldMeta>,
  overrides?: Record<string, FieldOverride>
): Record<string, FieldMeta> {
  if (!overrides) {
    return fields;
  }
  const output: Record<string, FieldMeta> = { ...fields };
  for (const [name, override] of Object.entries(overrides)) {
    const field = output[name];
    if (!field) {
      throw new Error(`DTO field "${name}" does not exist.`);
    }
    output[name] = normalizeOverride(field, override);
  }
  return output;
}

function normalizeOverride(field: FieldMeta, override: FieldOverride): FieldMeta {
  if (isSchemaNode(override)) {
    return {
      schema: override,
      optional: override.optional ?? field.optional ?? field.schema.optional,
      description: field.description
    };
  }
  const schema = override.schema ?? field.schema;
  const optional = override.optional ?? schema.optional ?? field.optional ?? field.schema.optional;
  return {
    schema,
    optional,
    description: override.description ?? field.description
  };
}

function isSchemaNode(value: unknown): value is SchemaNode {
  return !!value && typeof value === "object" && "kind" in (value as SchemaNode);
}

export interface PaginationConfig {
  defaultPageSize?: number;
  maxPageSize?: number;
}

export interface PaginationOptions {
  min?: number;
  max?: number;
  clamp?: boolean;
}

export interface ParsedPagination {
  page: number;
  pageSize: number;
}

export type CreateSessionFn = () => OrmSession;

export async function withSession<T>(
  createSession: CreateSessionFn,
  handler: (session: OrmSession) => Promise<T>
): Promise<T> {
  const session = createSession();
  try {
    return await handler(session);
  } finally {
    await session.dispose();
  }
}

export function parsePagination(
  query: Record<string, unknown>,
  config: PaginationConfig = {}
): ParsedPagination {
  const { defaultPageSize = 25, maxPageSize = 100 } = config;

  const page = coerce.integer(query.page as string | number, {
    min: 1,
    clamp: true
  }) ?? 1;

  const pageSize = coerce.integer(query.pageSize as string | number, {
    min: 1,
    max: maxPageSize,
    clamp: true
  }) ?? defaultPageSize;

  return { page, pageSize };
}

export function parseIdOrThrow(value: string | number, entityName: string): number {
  const id = coerce.id(value);
  if (id === undefined) {
    throw new HttpError(400, `Invalid ${entityName} id.`);
  }
  return id;
}

export interface FilterFieldMapping {
  [queryKey: string]: string;
}

export interface FilterMapping {
  field: string;
  operator: "equals" | "contains" | "startsWith" | "endsWith" | "gt" | "gte" | "lt" | "lte";
}

export interface ParseFilterOptions<T> {
  query?: Record<string, unknown>;
  fieldMappings?: Record<string, FilterMapping>;
}

export type Filter<T, K extends keyof T> = {
  [P in K]?: {
    equals?: T[P];
    contains?: T[P];
    startsWith?: T[P];
    endsWith?: T[P];
    gt?: T[P];
    gte?: T[P];
    lt?: T[P];
    lte?: T[P];
  };
};

export function parseFilter<T, K extends keyof T>(
  query: Record<string, unknown> | undefined,
  mappings: Record<string, { field: K; operator: "equals" | "contains" | "startsWith" | "endsWith" | "gt" | "gte" | "lt" | "lte" }>
): Filter<T, K> | undefined {
  if (!query) {
    return undefined;
  }

  const filter: Filter<T, K> = {};

  for (const [queryKey, value] of Object.entries(query)) {
    const mapping = mappings[queryKey];
    if (!mapping || value === undefined || value === null || value === "") {
      continue;
    }

    const { field, operator } = mapping;
    if (!filter[field]) {
      filter[field] = {};
    }
    filter[field]![operator] = value as T[K];
  }

  return Object.keys(filter).length ? filter : undefined;
}

export function createFilterMappings<T extends Record<string, unknown>>(
  entity: T,
  fields: Array<{ queryKey: string; field: keyof T; operator?: "equals" | "contains" | "startsWith" | "endsWith" }>
): Record<string, { field: keyof T; operator: "equals" | "contains" | "startsWith" | "endsWith" }> {
  const mappings: Record<string, { field: keyof T; operator: "equals" | "contains" | "startsWith" | "endsWith" }> = {};

  for (const { queryKey, field, operator = "equals" } of fields) {
    mappings[queryKey] = { field, operator };
  }

  return mappings;
}

export interface PagedQueryDtoOptions {
  defaultPageSize?: number;
  maxPageSize?: number;
  name?: string;
}

export function createPagedQueryDtoClass(
  options: PagedQueryDtoOptions = {}
): DtoConstructor {
  const { defaultPageSize = 25, maxPageSize = 100 } = options;

  @Dto({ name: options.name })
  class PagedQueryDto {
    @Field(t.optional(t.integer({ minimum: 1, default: 1 })))
    page?: number;

    @Field(
      t.optional(
        t.integer({ minimum: 1, maximum: maxPageSize, default: defaultPageSize })
      )
    )
    pageSize?: number;
  }

  return PagedQueryDto;
}

export interface PagedResponseDtoOptions {
  itemDto: DtoConstructor;
  description?: string;
  name?: string;
}

export function createPagedResponseDtoClass(
  options: PagedResponseDtoOptions
): DtoConstructor {
  const { itemDto, description, name } = options;

  @Dto()
  class ListItemsDto {
    @Field(t.array(t.ref(itemDto)))
    items!: unknown[];
  }

  @Dto()
  class PagedResponseMetaDto {
    @Field(t.integer({ minimum: 0 }))
    totalItems!: number;

    @Field(t.integer({ minimum: 1 }))
    page!: number;

    @Field(t.integer({ minimum: 1 }))
    pageSize!: number;

    @Field(t.integer({ minimum: 1 }))
    totalPages!: number;

    @Field(t.boolean())
    hasNextPage!: boolean;

    @Field(t.boolean())
    hasPrevPage!: boolean;
  }

  @MergeDto([ListItemsDto, PagedResponseMetaDto], {
    description: description ?? "Paged response.",
    name
  })
  class PagedResponseDto {}

  return PagedResponseDto;
}

export interface MetalCrudDtoOptions {
  overrides?: Record<string, FieldOverride>;
  response?: MetalDtoOptions;
  create?: MetalDtoOptions;
  replace?: MetalDtoOptions;
  update?: MetalDtoOptions;
  params?: MetalDtoOptions;
  mutationExclude?: string[];
  paramsInclude?: string[];
}

export interface MetalCrudDtoDecorators {
  response: ReturnType<typeof MetalDto>;
  create: ReturnType<typeof MetalDto>;
  replace: ReturnType<typeof MetalDto>;
  update: ReturnType<typeof MetalDto>;
  params: ReturnType<typeof MetalDto>;
}

export function createMetalCrudDtos(
  target: MetalDtoTarget,
  options: MetalCrudDtoOptions = {}
): MetalCrudDtoDecorators {
  const mutationExclude = options.mutationExclude;

  const response = buildCrudOptions(options.response, options.overrides);
  const create = buildCrudOptions(options.create, options.overrides, {
    mode: "create",
    exclude: mergeStringArrays(mutationExclude, options.create?.exclude)
  });
  const replace = buildCrudOptions(options.replace, options.overrides, {
    mode: "create",
    exclude: mergeStringArrays(mutationExclude, options.replace?.exclude)
  });
  const update = buildCrudOptions(options.update, options.overrides, {
    mode: "update",
    exclude: mergeStringArrays(mutationExclude, options.update?.exclude)
  });

  const params = buildCrudOptions(options.params, options.overrides);
  params.include = params.include ?? options.paramsInclude ?? ["id"];

  return {
    response: MetalDto(target, response),
    create: MetalDto(target, create),
    replace: MetalDto(target, replace),
    update: MetalDto(target, update),
    params: MetalDto(target, params)
  };
}

function mergeOverrides(
  base?: Record<string, FieldOverride>,
  override?: Record<string, FieldOverride>
): Record<string, FieldOverride> | undefined {
  if (!base && !override) {
    return undefined;
  }
  return { ...(base ?? {}), ...(override ?? {}) };
}

function mergeStringArrays(
  ...entries: Array<string[] | undefined>
): string[] | undefined {
  const merged = new Set<string>();
  for (const entry of entries) {
    for (const value of entry ?? []) {
      merged.add(value);
    }
  }
  return merged.size ? Array.from(merged) : undefined;
}

function buildCrudOptions(
  base: MetalDtoOptions | undefined,
  overrides: Record<string, FieldOverride> | undefined,
  extra: Partial<MetalDtoOptions> = {}
): MetalDtoOptions {
  const mergedOverrides = mergeOverrides(overrides, base?.overrides);
  const output: MetalDtoOptions = { ...base, ...extra };
  if (mergedOverrides) {
    output.overrides = mergedOverrides;
  }
  return output;
}
