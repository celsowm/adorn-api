import path from "path";
import { Project, ClassDeclaration, PropertyDeclaration, SyntaxKind } from "ts-morph";
import * as fs from "fs";
import type { AdornConfig } from "../core/config.js";
import { DEFAULT_STATUS_CODES } from "../core/config.js";
import { createValidationAdapter } from "../lib/adapters.js";

export async function generateRoutes(config: AdornConfig): Promise<void> {
  const generation = config.generation;
  const runtime = config.runtime;
  const project = new Project({ tsConfigFilePath: generation.tsConfig });
  
  let routeCode = `/* tslint:disable */
/* eslint-disable */
// WARNING: This file was auto-generated by adorn-api. Do not edit.
import { Express, Request, Response, NextFunction } from 'express';
import { DefaultAuthAdapter, ClassInstantiatingDTOFactory, DefaultErrorAdapter } from 'adorn-api';
import multer from 'multer';
`;

  const imports = new Set<string>();
  const multerInstances = new Map<string, string>();

  function processController(classDec: ClassDeclaration): string {
    const className = classDec.getName();
    if (!className) return "";

    const sourceFile = classDec.getSourceFile();
    const outputDir = path.dirname(path.resolve(generation.routesOutput));
    const relativeDir = path.relative(outputDir, sourceFile.getDirectoryPath());
    const relativeSegments = relativeDir ? relativeDir.split(path.sep) : [];
    const baseName = sourceFile.getBaseName().replace(/\.ts$/, ".js");
    const importPath = `./${path.posix.join(...relativeSegments, baseName)}`;
    
    if (classDec.isExported()) {
      imports.add(`import { ${className} } from '${importPath}';`);
    } else {
      console.warn(`Warning: Controller ${className} is not exported, skipping route generation`);
      return "";
    }

    const controllerDec = classDec.getDecorators().find(d => d.getName() === "Controller");
    if (!controllerDec) return "";

    const controllerBasePath = controllerDec.getArguments()[0]?.getText().replace(/['"]/g, "") || "/";
    let methodBlocks = "";

    classDec.getMethods().forEach(method => {
      const getDec = method.getDecorator("Get");
      const postDec = method.getDecorator("Post");
      const putDec = method.getDecorator("Put");
      const deleteDec = method.getDecorator("Delete");
      const patchDec = method.getDecorator("Patch");
      const decorator = getDec || postDec || putDec || deleteDec || patchDec;
      if (!decorator) return;

      const httpMethod = getDec ? "get" : postDec ? "post" : putDec ? "put" : deleteDec ? "delete" : "patch";
      const pathArg = decorator.getArguments()[0]?.getText().replace(/['"]/g, "") || "/";
      const globalBasePath = generation.basePath || "";
      const fullPath = normalizePath(globalBasePath, controllerBasePath, pathArg);

      const methodName = method.getName();
      const params = method.getParameters();
      const authDec = method.getDecorator("Authorized");
      const controllerAuthDec = classDec.getDecorators().find(d => d.getName() === "Authorized");
      const hasAuth = !!authDec || !!controllerAuthDec;
      let authRole = undefined;
      if (authDec) {
        authRole = authDec.getArguments()[0]?.getText().replace(/['"]/g, "");
      } else if (controllerAuthDec) {
        authRole = controllerAuthDec.getArguments()[0]?.getText().replace(/['"]/g, "");
      }
      const statusDec = method.getDecorator("Status");
      const customStatus = statusDec ? Number(statusDec.getArguments()[0]?.getText()) : undefined;
      const defaultStatus = DEFAULT_STATUS_CODES[httpMethod];
      const statusCode = customStatus ?? defaultStatus;
      const hasValidation = runtime.validationEnabled || false;
      
      let hasFileUpload = false;
      let fileFieldConfigs: Array<{ fieldName: string; maxCount: number }> = [];
      
      if (params.length > 0) {
        const param = params[0];
        const paramType = param.getType();
        const properties = paramType.getProperties();
        
        for (const prop of properties) {
          const declarations = prop.getDeclarations();
          for (const decl of declarations) {
            if (decl.getKind() === SyntaxKind.PropertyDeclaration) {
              const pDecl = decl as PropertyDeclaration;
              const uploadedFileDec = pDecl.getDecorator("UploadedFile");
              if (uploadedFileDec) {
                hasFileUpload = true;
                const fieldName = uploadedFileDec.getArguments()[0]?.getText().replace(/['"]/g, "") || "file";
                const maxCountArg = uploadedFileDec.getArguments()[1];
                const maxCount = maxCountArg ? Number(maxCountArg.getText()) : 1;
                fileFieldConfigs.push({ fieldName, maxCount });
              }
            }
          }
        }
      }
      
      let middlewareChain: string[] = [];
      if (hasFileUpload) {
        const multerInstanceName = `upload_${className}_${methodName}`;
        let fieldsCode = fileFieldConfigs.map(f => 
          `{ name: '${f.fieldName}', maxCount: ${f.maxCount} }`
        ).join(", ");
        multerInstances.set(multerInstanceName, `const ${multerInstanceName} = multer({ dest: 'uploads/' }).fields([${fieldsCode}]);`);
        middlewareChain.push(`${multerInstanceName}`);
      }
      
      let paramInstantiation = "";
      let methodCallParams: string[] = [];
      
      if (params.length > 0) {
        params.forEach(param => {
          const paramName = param.getName();
          const paramType = param.getType();
          const paramTypeSymbol = paramType.getSymbol();
          
          if (paramTypeSymbol) {
            const paramTypeName = paramTypeSymbol.getName();
            const paramSourceFile = paramTypeSymbol.getDeclarations()[0]?.getSourceFile();
            
            if (paramSourceFile === sourceFile && paramType.isClass()) {
              imports.add(`import { ${paramTypeName} } from '${importPath}';`);
            }
            
            paramInstantiation += `
        // DTO: ${paramName} (${paramTypeName})
        let ${paramName}: any = {};
        // Map Query
        Object.assign(${paramName}, req.query);
        // Map Params
        Object.assign(${paramName}, req.params);
        // Map Body
        Object.assign(${paramName}, req.body);
        // Map Headers
        Object.assign(${paramName}, req.headers);
        // Map Cookies
        Object.assign(${paramName}, req.cookies || {});
`;
            if (hasFileUpload) {
              paramInstantiation += `        // Map Files
        if (req.files) {
            ${fileFieldConfigs.map(f => `${paramName}.${f.fieldName} = req.files['${f.fieldName}'];`).join('\n            ')}
        }
`;
            }
            
            if (runtime.useClassInstantiation) {
              paramInstantiation += `
        // Instantiate DTO class
        const ${paramName}Instance = new ${paramTypeName}();
        Object.assign(${paramName}Instance, ${paramName});
        ${paramName} = ${paramName}Instance;
`;
            }
            
            if (hasValidation) {
              paramInstantiation += `
        // Validate DTO
        try {
            const validationAdapter = await (await import('adorn-api')).createValidationAdapter({ validationLibrary: '${runtime.validationLibrary || 'none'}', validationPath: ${runtime.validationPath ? `'${runtime.validationPath}'` : 'undefined'} });
            await validationAdapter.validate(${paramName}, ${paramTypeName});
        } catch (validationError: any) {
            return res.status(400).json({ error: 'Validation failed', details: validationError.message });
        }
`;
            }
            
            methodCallParams.push(paramName);
          } else {
            if (paramName === 'req') {
              methodCallParams.push('req');
            } else if (paramName === 'res') {
              methodCallParams.push('res');
            } else if (paramName === 'next') {
              methodCallParams.push('next');
            } else {
              paramInstantiation += `
        const ${paramName} = (req.body as any)?.${paramName} || (req.params as any)?.${paramName} || (req.query as any)?.${paramName};
`;
              methodCallParams.push(paramName);
            }
          }
        });
      }

      let responseHandling = "";
      if (statusCode === 204) {
        responseHandling = `res.status(${statusCode}).send();`;
      } else {
        responseHandling = `res.status(${statusCode}).json(response);`;
      }

      if (hasAuth) {
        const roleArg = authRole ? `'${authRole}'` : 'undefined';
        middlewareChain.push(`authAdapter.getMiddleware(${roleArg})`);
      }

      methodBlocks += `
    app.${httpMethod}('${fullPath}', [${middlewareChain.join(', ')}], async (req: Request, res: Response, next: NextFunction) => {
        const controller = new ${className}();
        
        // Initialize adapters
        const errorAdapter = ${runtime.errorAdapterPath ? `require('${runtime.errorAdapterPath}').default || require('${runtime.errorAdapterPath}').ErrorAdapter` : 'new DefaultErrorAdapter()'};
        
        try {
            ${paramInstantiation}
            const response = await controller.${methodName}(${methodCallParams.join(', ')});
            ${responseHandling}
        } catch (err: any) {
            const transformedError = errorAdapter.handleError(err);
            next(transformedError);
        }
    });
    `;
    });

    return methodBlocks;
  }

  const sourceFiles = project.getSourceFiles(generation.controllersGlob);
  let allRoutes = "";

  sourceFiles.forEach(file => {
    file.getClasses().forEach(c => {
      allRoutes += processController(c);
    });
  });

  let multerInstancesCode = Array.from(multerInstances.values()).join('\n    ');
  if (multerInstancesCode) {
    multerInstancesCode = `\n    // Multer instances for file uploads\n    ${multerInstancesCode}\n`;
  }

  routeCode += Array.from(imports).join('\n');
  routeCode += `

export function RegisterRoutes(app: Express) {
    ${multerInstancesCode}
    ${allRoutes}
}
`;

  const outputDir = path.dirname(generation.routesOutput);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  fs.writeFileSync(generation.routesOutput, routeCode);
  console.log(`âœ… Generated Routes at ${generation.routesOutput}`);
}

function normalizePath(globalBase: string, controllerBase: string, methodPath: string): string {
  const cleanGlobal = globalBase.replace(/^\/+/g, '');
  const cleanController = controllerBase.replace(/^\/+/g, '');
  const cleanMethod = methodPath.replace(/^\/+/g, '');
  const parts: string[] = [];
  if (cleanGlobal) parts.push(cleanGlobal);
  if (cleanController) parts.push(cleanController);
  if (cleanMethod) parts.push(cleanMethod);
  let fullPath = '/' + parts.join('/');
  fullPath = fullPath.replace(/{/g, ':').replace(/}/g, '');
  return fullPath;
}
