// src/cli/generate-routes.ts
import path from "path";
import { Project, ClassDeclaration, PropertyDeclaration, SyntaxKind } from "ts-morph";
import * as fs from "fs";
import type { AdornConfig } from "../lib/config.js";
import { DEFAULT_STATUS_CODES } from "../lib/config.js";

export async function generateRoutes(config: AdornConfig): Promise<void> {
  const project = new Project({ tsConfigFilePath: config.tsConfig });
  
  let routeCode = `/* tslint:disable */
/* eslint-disable */
// WARNING: This file was auto-generated by adorn-api. Do not edit.
import { Express, Request, Response, NextFunction } from 'express';
`;

  // Helper to keep track of imports we need to add to the generated file
  const imports = new Set<string>();

  function processController(classDec: ClassDeclaration): string {
    const className = classDec.getName();
    if (!className) return "";

    // Get source file path for import
    const sourceFile = classDec.getSourceFile();
    const outputDir = path.dirname(path.resolve(config.routesOutput));
    const relativeDir = path.relative(outputDir, sourceFile.getDirectoryPath());
    const relativeSegments = relativeDir ? relativeDir.split(path.sep) : [];
    const baseName = sourceFile.getBaseName().replace(/\.ts$/, ".js");
    const importPath = `./${path.posix.join(...relativeSegments, baseName)}`;
    
    // Only import if the class is exported
    if (classDec.isExported()) {
      imports.add(`import { ${className} } from '${importPath}';`);
    } else {
      console.warn(`Warning: Controller ${className} is not exported, skipping route generation`);
      return "";
    }

    const controllerDec = classDec.getDecorators().find(d => d.getName() === "Controller");
    if (!controllerDec) return "";

    const controllerBasePath = controllerDec.getArguments()[0]?.getText().replace(/['"]/g, "") || "/";
    let methodBlocks = "";

    classDec.getMethods().forEach(method => {
      const getDec = method.getDecorator("Get");
      const postDec = method.getDecorator("Post");
      const putDec = method.getDecorator("Put");
      const deleteDec = method.getDecorator("Delete");
      const decorator = getDec || postDec || putDec || deleteDec;
      if (!decorator) return;

      const httpMethod = getDec ? "get" : postDec ? "post" : putDec ? "put" : "delete";
      const pathArg = decorator.getArguments()[0]?.getText().replace(/['"]/g, "") || "/";
      
      // Normalize path: handle basePath + controllerBasePath + method path
      const globalBasePath = config.basePath || "";
      const fullPath = normalizePath(globalBasePath, controllerBasePath, pathArg);

      const methodName = method.getName();
      const params = method.getParameters();
      
      // Authentication check
      const authDec = method.getDecorator("Authorized");
      const controllerAuthDec = classDec.getDecorator("Authorized");
      const hasAuth = !!authDec || !!controllerAuthDec;
      const middlewareArgs = hasAuth ? "authenticationMiddleware, " : "";
      
      // Status code determination
      const statusDec = method.getDecorator("Status");
      const customStatus = statusDec ? Number(statusDec.getArguments()[0]?.getText()) : undefined;
      const defaultStatus = DEFAULT_STATUS_CODES[httpMethod];
      const statusCode = customStatus ?? defaultStatus;
      
      // Logic to instantiate the DTO
      let paramInstantiation = "";
      if (params.length > 0) {
        const paramName = params[0].getName();
        const paramType = params[0].getType();
        const paramTypeSymbol = paramType.getSymbol();
        
        // Only generate DTO handling if it's a class/interface type
        if (paramTypeSymbol) {
          const paramTypeName = paramTypeSymbol.getName();
          const paramSourceFile = paramTypeSymbol.getDeclarations()[0]?.getSourceFile();
          
          // Only import if it's in the same file (for simplicity in this phase)
          // In Phase 2, we'll improve DTO import handling
          paramInstantiation = `
        const input: any = {};
        // Map Query
        Object.assign(input, req.query);
        // Map Params
        Object.assign(input, req.params);
        // Map Body
        Object.assign(input, req.body);
        
        // In a real app, you would run 'zod' or 'class-validator' here on 'input'
      `;
        }
      }

      // Response handling based on status code
      let responseHandling = "";
      if (statusCode === 204) {
        responseHandling = `res.status(${statusCode}).send();`;
      } else {
        responseHandling = `res.status(${statusCode}).json(response);`;
      }

      methodBlocks += `
    app.${httpMethod}('${fullPath}', ${middlewareArgs}async (req: Request, res: Response, next: NextFunction) => {
        const controller = new ${className}();
        try {
            ${paramInstantiation}
            const response = await controller.${methodName}(${params.length > 0 ? 'input' : ''});
            ${responseHandling}
        } catch (err: any) {
            next(err);
        }
    });
    `;
    });

    return methodBlocks;
  }

  const sourceFiles = project.getSourceFiles(config.controllersGlob);
  let allRoutes = "";

  sourceFiles.forEach(file => {
    file.getClasses().forEach(c => {
      allRoutes += processController(c);
    });
  });

  // Add authentication middleware import if needed
  if (allRoutes.includes('authenticationMiddleware')) {
    routeCode += `import { authenticationMiddleware } from '${config.authMiddlewarePath}';\n`;
  }

  // Prepend imports
  routeCode += Array.from(imports).join('\n');
  routeCode += `

export function RegisterRoutes(app: Express) {
    ${allRoutes}
}
`;

  // Ensure output directory exists
  const outputDir = path.dirname(config.routesOutput);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  fs.writeFileSync(config.routesOutput, routeCode);
  console.log(`âœ… Generated Routes at ${config.routesOutput}`);
}

/**
 * Normalize route paths to ensure proper joining
 * Handles edge cases like missing/extra slashes
 */
function normalizePath(globalBase: string, controllerBase: string, methodPath: string): string {
  // Remove leading/trailing slashes
  const cleanGlobal = globalBase.replace(/^\/+|\/+$/g, '');
  const cleanController = controllerBase.replace(/^\/+|\/+$/g, '');
  const cleanMethod = methodPath.replace(/^\/+|\/+$/g, '');
  
  // Build path parts
  const parts: string[] = [];
  if (cleanGlobal) parts.push(cleanGlobal);
  if (cleanController) parts.push(cleanController);
  if (cleanMethod) parts.push(cleanMethod);
  
  // Join with single slashes and convert {param} to :param for Express
  let fullPath = '/' + parts.join('/');
  fullPath = fullPath.replace(/{/g, ':').replace(/}/g, '');
  
  return fullPath;
}
