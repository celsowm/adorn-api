// src/cli/generate-routes.ts
import path from "path";
import { Project } from "ts-morph";
import * as fs from "fs";
import { DEFAULT_STATUS_CODES } from "../lib/config.js";
export async function generateRoutes(config) {
    const project = new Project({ tsConfigFilePath: config.tsConfig });
    let routeCode = `/* tslint:disable */
/* eslint-disable */
// WARNING: This file was auto-generated by adorn-api. Do not edit.
import { Express, Request, Response, NextFunction } from 'express';
import { DefaultAuthAdapter, ClassInstantiatingDTOFactory, DefaultErrorAdapter } from 'adorn-api';
`;
    // Helper to keep track of imports we need to add to the generated file
    const imports = new Set();
    function processController(classDec) {
        const className = classDec.getName();
        if (!className)
            return "";
        // Get source file path for import
        const sourceFile = classDec.getSourceFile();
        const outputDir = path.dirname(path.resolve(config.routesOutput));
        const relativeDir = path.relative(outputDir, sourceFile.getDirectoryPath());
        const relativeSegments = relativeDir ? relativeDir.split(path.sep) : [];
        const baseName = sourceFile.getBaseName().replace(/\.ts$/, ".js");
        const importPath = `./${path.posix.join(...relativeSegments, baseName)}`;
        // Only import if the class is exported
        if (classDec.isExported()) {
            imports.add(`import { ${className} } from '${importPath}';`);
        }
        else {
            console.warn(`Warning: Controller ${className} is not exported, skipping route generation`);
            return "";
        }
        const controllerDec = classDec.getDecorators().find(d => d.getName() === "Controller");
        if (!controllerDec)
            return "";
        const controllerBasePath = controllerDec.getArguments()[0]?.getText().replace(/['"]/g, "") || "/";
        let methodBlocks = "";
        classDec.getMethods().forEach(method => {
            const getDec = method.getDecorator("Get");
            const postDec = method.getDecorator("Post");
            const putDec = method.getDecorator("Put");
            const deleteDec = method.getDecorator("Delete");
            const patchDec = method.getDecorator("Patch");
            const decorator = getDec || postDec || putDec || deleteDec || patchDec;
            if (!decorator)
                return;
            const httpMethod = getDec ? "get" : postDec ? "post" : putDec ? "put" : deleteDec ? "delete" : "patch";
            const pathArg = decorator.getArguments()[0]?.getText().replace(/['"]/g, "") || "/";
            // Normalize path: handle basePath + controllerBasePath + method path
            const globalBasePath = config.basePath || "";
            const fullPath = normalizePath(globalBasePath, controllerBasePath, pathArg);
            const methodName = method.getName();
            const params = method.getParameters();
            // Authentication check with role support
            const authDec = method.getDecorator("Authorized");
            const controllerAuthDec = classDec.getDecorator("Authorized");
            const hasAuth = !!authDec || !!controllerAuthDec;
            // Get auth role if specified
            let authRole = undefined;
            if (authDec) {
                authRole = authDec.getArguments()[0]?.getText().replace(/['"]/g, "");
            }
            else if (controllerAuthDec) {
                authRole = controllerAuthDec.getArguments()[0]?.getText().replace(/['"]/g, "");
            }
            // Status code determination
            const statusDec = method.getDecorator("Status");
            const customStatus = statusDec ? Number(statusDec.getArguments()[0]?.getText()) : undefined;
            const defaultStatus = DEFAULT_STATUS_CODES[httpMethod];
            const statusCode = customStatus ?? defaultStatus;
            // Build parameter handling - supports multiple parameters
            let paramInstantiation = "";
            let methodCallParams = [];
            if (params.length > 0) {
                params.forEach((param, index) => {
                    const paramName = param.getName();
                    const paramType = param.getType();
                    const paramTypeSymbol = paramType.getSymbol();
                    // Check if this is a DTO class type
                    if (paramTypeSymbol) {
                        const paramTypeName = paramTypeSymbol.getName();
                        const paramSourceFile = paramTypeSymbol.getDeclarations()[0]?.getSourceFile();
                        // Only import if it's from the same file as the controller
                        if (paramSourceFile === sourceFile) {
                            const isSameFile = paramSourceFile === sourceFile;
                            if (isSameFile && paramType.isClass()) {
                                imports.add(`import { ${paramTypeName} } from '${importPath}';`);
                            }
                        }
                        // Generate DTO instantiation code
                        paramInstantiation += `
        // DTO: ${paramName} (${paramTypeName})
        let ${paramName}: any = {};
        // Map Query
        Object.assign(${paramName}, req.query);
        // Map Params
        Object.assign(${paramName}, req.params);
        // Map Body
        Object.assign(${paramName}, req.body);
`;
                        // Use DTO factory if configured
                        if (config.useClassInstantiation) {
                            paramInstantiation += `
        // Instantiate DTO class
        const ${paramName}Instance = new ${paramTypeName}();
        Object.assign(${paramName}Instance, ${paramName});
        ${paramName} = ${paramName}Instance;
`;
                        }
                        methodCallParams.push(paramName);
                    }
                    else {
                        // Primitive type or special parameter (req, res, next)
                        if (paramName === 'req') {
                            paramInstantiation += `        const req = req; // Already available\n`;
                            methodCallParams.push('req');
                        }
                        else if (paramName === 'res') {
                            paramInstantiation += `        const res = res; // Already available\n`;
                            methodCallParams.push('res');
                        }
                        else if (paramName === 'next') {
                            paramInstantiation += `        const next = next; // Already available\n`;
                            methodCallParams.push('next');
                        }
                        else {
                            // Unknown primitive - try to map from request
                            paramInstantiation += `
        const ${paramName} = (req.body as any)?.${paramName} || (req.params as any)?.${paramName} || (req.query as any)?.${paramName};
`;
                            methodCallParams.push(paramName);
                        }
                    }
                });
            }
            // Response handling based on status code
            let responseHandling = "";
            if (statusCode === 204) {
                responseHandling = `res.status(${statusCode}).send();`;
            }
            else {
                responseHandling = `res.status(${statusCode}).json(response);`;
            }
            // Build middleware invocation
            let middlewareInvocation = "";
            if (hasAuth) {
                const roleArg = authRole ? `'${authRole}'` : 'undefined';
                middlewareInvocation = `await authAdapter.getMiddleware(${roleArg})(req, res, next);`;
            }
            methodBlocks += `
    app.${httpMethod}('${fullPath}', async (req: Request, res: Response, next: NextFunction) => {
        const controller = new ${className}();
        
        // Initialize adapters
        const authAdapter = new DefaultAuthAdapter('${config.authMiddlewarePath}');
        const errorAdapter = ${config.errorAdapterPath ? `require('${config.errorAdapterPath}').default || require('${config.errorAdapterPath}').ErrorAdapter` : 'new DefaultErrorAdapter()'};
        
        try {
            ${hasAuth ? `// Authentication check\n            ${middlewareInvocation}\n` : ''}
            ${paramInstantiation}
            const response = await controller.${methodName}(${methodCallParams.join(', ')});
            ${responseHandling}
        } catch (err: any) {
            const transformedError = errorAdapter.handleError(err);
            next(transformedError);
        }
    });
    `;
        });
        return methodBlocks;
    }
    const sourceFiles = project.getSourceFiles(config.controllersGlob);
    let allRoutes = "";
    sourceFiles.forEach(file => {
        file.getClasses().forEach(c => {
            allRoutes += processController(c);
        });
    });
    // Prepend imports
    routeCode += Array.from(imports).join('\n');
    routeCode += `

export function RegisterRoutes(app: Express) {
    ${allRoutes}
}
`;
    // Ensure output directory exists
    const outputDir = path.dirname(config.routesOutput);
    if (!fs.existsSync(outputDir)) {
        fs.mkdirSync(outputDir, { recursive: true });
    }
    fs.writeFileSync(config.routesOutput, routeCode);
    console.log(`âœ… Generated Routes at ${config.routesOutput}`);
}
/**
 * Normalize route paths to ensure proper joining
 * Handles edge cases like missing/extra slashes
 */
function normalizePath(globalBase, controllerBase, methodPath) {
    // Remove leading/trailing slashes
    const cleanGlobal = globalBase.replace(/^\/+|\/+$/g, '');
    const cleanController = controllerBase.replace(/^\/+|\/+$/g, '');
    const cleanMethod = methodPath.replace(/^\/+|\/+$/g, '');
    // Build path parts
    const parts = [];
    if (cleanGlobal)
        parts.push(cleanGlobal);
    if (cleanController)
        parts.push(cleanController);
    if (cleanMethod)
        parts.push(cleanMethod);
    // Join with single slashes and convert {param} to :param for Express
    let fullPath = '/' + parts.join('/');
    fullPath = fullPath.replace(/{/g, ':').replace(/}/g, '');
    return fullPath;
}
